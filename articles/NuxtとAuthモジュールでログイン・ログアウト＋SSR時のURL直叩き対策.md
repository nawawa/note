SSR構成で作成したNuxtアプリケーションへただ単に認証の機能を付ける分には、割と簡単です。

ただNuxtアプリケーションにおいて懸念となるのは、NuxtLinkで遷移する場合と、URLを直に入力された場合をそれぞれ考慮しなければならないことです。ここが割と初心者殺しな部分というか、実際めんどくさい。

まあそれはさておき、いったん認証機能を付けるところまで行った作業についてまとめます。

APIサーバー：Laravel9.10.1

Nuxt.js：@nuxt/cli v2.15.8

※TypeScriptの学習を後に回しているので、Nuxt2系でやってます。CompositionAPIも使いません。

## Laravel側の設定

CORSとセッション管理の設定をする必要があります。

CORS（オリジン間リソース共有）について簡単に説明すると、基本的にはサーバーが保持するコンテンツはサーバーが配信するHTMLによって提供されるよう決められているところを、サーバーAのリソースをサーバーBが利用できるようにするための設定のことです。今回の構成でいえば、Laravelが乗ってるサーバーのリソースを、Nuxt（をレンダリングするNode.js）のサーバーが利用できるようにするために必要ということです。

セッションは、Webサーバーがクライアントごとに保持する情報たちのことです。ブラウザが閉じられるまでの間維持されます。セッションはクライアントごとに固有であり、セッションIDという値によって、サーバーが現在通信を行っている相手を識別します。今回はSanctumというパッケージを使って認証を行いますが、SanctumのSPA認証という認証方法は、このセッションIDを使って「ログイン中」の状態を作ります。

SanctumでNuxtアプリケーションを認証する方法としては、実装手順を解説している記事のほとんどが、JWTトークンを用いた方式を採用しているようです。これはSanctumが提供している認証方法のひとつではありますが、この方法を取るには、JWTトークンをSPA側で保持する必要があります。NuxtであればVuexストアに格納するなどが考えられますが、ストアの情報はページをリロードすれば消えます。かといってブラウザ側で保持するためにはCookieかローカルストレージのいずれかに格納する必要が生じますが、ローカルストレージはJavaScriptで簡単にアクセスできてしまうのでセキュリティ的に安全ではなく、Cookieに格納するにしても、SSRするとなればCookie内のトークンをNode.jsサーバー側でも使えるようにしないといけません。セッションIDをCookieに格納する従来の方式であれば、そのへんはAuthモジュールがよしなにやってくれます。

結局の所、REST原則に反することについては妥協して、API側のエンドポイントをステートフルにしてしまうのが一番安全かつ簡単、というのが現在の定石であるようです。

## Nuxt側の設定

こっちがややこしいです。

まずAxiosの設定についてですが、最終こんな感じになっています。

```js
  axios: {
    prefix: process.env.API_URL, // baseURLの代わり
    proxy: true,
    credentials: true,
  },

  proxy: {
    '/laravel': {
      target: process.env.NODE_URL,
      pathRewrite: { '^/laravel': '/' }
    },
    '/api/': process.env.SERVER_URL,
  },
```



どうやってmiddlewareの時点でログイン状態を参照するか？

セッションの有無を見ている人もいる(req.session)

あるいは有効なCookieがあるかを見ている人もいる(req.headers.cookie)

今回はnuxtserverinitでstoreを更新したあと、middlewareでstoreを参照するやり方にしてみた。

