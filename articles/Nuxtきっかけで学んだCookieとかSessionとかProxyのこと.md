Cookieとは：ブラウザに格納されるストレージ

Sanctumでいう「SPA認証」は、セッションを用いたステートフル認証（サーバー側で認証状態を維持すること）である

ユーザーの識別はHttpOnlyクッキーにのみ依存するため、XSS攻撃によって盗まれることがないという利点がある

HttpOnlyというのは、Cookieの属性のこと。JavaScriptからアクセスできないのでセッションIDを盗まれずに済む。

※Secureという属性もある。これは、https通信でないとアクセスできないという意味。

Sanctumの設定では、SPAのドメインからのリクエストによってセッションを開始するために、ミドルウェアを使って強制的にステートフルとみなすように設定する必要がある。環境変数のSANCTUM_STATEFULL_DOMAINはそのための値。

認証処理の流れ：

/sanctum/csrf-cookieを叩いてCSRFトークンを取得する
悪意のあるアクセスを防ぐためのトークン。本来であればサーバーが提供するフォームにhiddenで入っている値だが、SPAではそういったことができないため、手動で取得する必要があるということ。

ブラウザのミドルウェアが認証ヘッダを付与した上で応答し、実際にGETリクエストが送信される。

SPAは取得されたトークンをX-XSRF-TOKENヘッダの値に付与し、ログインのためのPOSTリクエストを送信する。

Laravel側のミドルウェアが、そのリクエストで新しくセッションを開始するかどうかを判定する。リクエスト元のドメインが環境変数のSANCTUM_STATEFULL_DOMAINSに設定されていればセッションを開始する。

この際Cookieは、SESSION_DOMAINに宣言されているドメインに設定される。

```
EnsureFrontendRequestsAreStateful::class
```

このクラスの役割は、SANCTUM_STATEFUL_DOMAINSに列挙されたドメインに限ってセッションをステートフルにすること。

Proxyというのは、ホスト（リクエスト先）とクライアント（リクエスト元）の間に入る中継地点のこと。

基本的にはセキュリティ目的でプロキシサーバーを挟み込む事が多いが、Nuxtで構築したアプリケーションをSSRするとき、SSR用にAPIサーバーとは別にフロントエンド用のNode.jsサーバーを構築した場合は、必然的にそれがプロキシサーバーとして機能することになる。

APIサーバーから見ると、Node.jsサーバーがクライアントになる。なので、APIサーバーのCORSはNode.jsサーバーに対して許可しなければならない。

一方Node.jsサーバーに関しては、ブラウザからのリクエストをAPIサーバーへ回すように設定しなければならない。その設定箇所がproxyに記載するtarget。値としてAPIサーバーのオリジン（プロトコル・ドメイン・ポート番号）を渡す。

---

APIサーバーのオリジンとNode.jsサーバーのオリジンとでリソースを共有できるように設定した他に、SanctumはCookieにセッション情報を格納することによって（殆どの場合）認証するので、セッション情報をそれぞれで管理できるようにセットアップする必要がある。

今回使っているLaravelであれば、セッションを行うドメインを環境変数として定義するのと、セッションの管理方法をデフォルトのfileからcookieに変える変更を行えばいい。

問題はNuxtの方で、要するにNode.jsサーバーがCookieを参照できるようにしないといけないというか、Cookieに格納されてるセッションIDをNode.jsサーバーと共有しないといけないというか、何をどうすればよいやらよくわからないアレがナニで、結局そこがよくわからないまま。いろんな記事を見てみたけど、nuxt-universal-cookieやらcookie-parserやら「これ使ったらいい」と言われてるパッケージもマチマチな印象。

結局の所、axios同様Nuxtの標準モジュールとして配布されているauth-nextを使ってみることにした。最定番があるならそれにしとこう。

---

`context.$auth.loggedIn`の値が、ミドルウェアとコンポーネントで異なる。どうしてこんなことになる？